{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "]},"docs":[{"location":"","title":"Cyfrowe przetwarzanie sygna\u0142\u00f3w i obraz\u00f3w","text":""},{"location":"#laboratorium-przetwarzanie-i-analiza-sygnau-ekg","title":"Laboratorium: Przetwarzanie i analiza sygna\u0142u EKG","text":""},{"location":"#wstep","title":"Wst\u0119p","text":"<p>W ramach tego laboratorium, zosta\u0142y wykonane zadania zwi\u0105zane z przetwarzaniem i analiz\u0105 sygna\u0142\u00f3w EKG za pomoc\u0105 j\u0119zyk\u00f3w programowania Python i Matlab. Celem by\u0142o zdobycie umiej\u0119tno\u015bci wczytywania, przetwarzania, analizowania oraz filtrowania sygna\u0142\u00f3w EKG.</p>"},{"location":"#plan-cwiczen-laboratoryjnych","title":"Plan \u0107wicze\u0144 laboratoryjnych","text":"<ol> <li>Platforma testowa</li> <li>Testowe sygna\u0142y EKG</li> <li>Analiza okresowych sygna\u0142\u00f3w w dziedzinie cz\u0119stotliwo\u015bci</li> <li>Filtracja sygna\u0142u EKG</li> </ol>"},{"location":"#szczegoy-zadan","title":"Szczeg\u00f3\u0142y zada\u0144","text":""},{"location":"#cwiczenie-1-platforma-testowa","title":"\u0106wiczenie 1: Platforma testowa","text":"<p>Napisz skrypt w Pythonie/Matlabie umo\u017cliwiaj\u0105cy wczytywanie i wizualizacj\u0119 badanych sygna\u0142\u00f3w. Program powinien umo\u017cliwia\u0107 obserwowanie wniosk\u00f3w sygna\u0142u dla zadanego przedzia\u0142u czasowego, skalowanie osi warto\u015bci i ich opis oraz zapis dowolnego wycinka sygna\u0142u do pliku o podanej nazwie.</p> <p>Pliki sygna\u0142\u00f3w EKG: - <code>ekg1.txt</code> - 12 kolumn odpowiadaj\u0105cych odpowiedziom, f<sub>s</sub> = 1000 Hz - <code>ekg10.txt</code> - 1 kolumna, f<sub>s</sub> = 360 Hz - <code>ekg_noise.txt</code> - 1 kolumna: czas, 2 kolumna: warto\u015bci amplitud EKG, f<sub>s</sub> = 360 Hz</p>"},{"location":"#cwiczenie-2-analiza-okresowych-sygnaow-w-dziedzinie-czestotliwosci","title":"\u0106wiczenie 2: Analiza okresowych sygna\u0142\u00f3w w dziedzinie cz\u0119stotliwo\u015bci","text":"<p>Celem \u0107wiczenia jest praktyczne wypr\u00f3bowanie funkcji <code>numpy.fft</code> do wyznaczania prostej i odwrotnej transformacji Fouriera.</p> <p>Zadania: 1. Wygeneruj plik odpowiadaj\u0105cy fali sinusoidalnej o cz\u0119stotliwo\u015bci 50 Hz i d\u0142ugo\u015bci 65536. 2. Wyznacz dyskretn\u0105 transformacj\u0119 Fouriera tego sygna\u0142u i przedstaw jego widmo amplitudowe. 3. Powt\u00f3rz eksperymenty dla r\u00f3\u017cnych czas\u00f3w trwania sygna\u0142\u00f3w. 4. Wyznacz odwrotn\u0105 transformacj\u0119 Fouriera ci\u0105g\u00f3w wyznaczonych w zadaniu 3.</p>"},{"location":"#cwiczenie-3-analiza-sygnau-ekg-w-dziedzinie-czestotliwosci","title":"\u0106wiczenie 3: Analiza sygna\u0142u EKG w dziedzinie cz\u0119stotliwo\u015bci","text":"<p>Celem \u0107wiczenia jest obserwacja widma sygna\u0142u EKG.</p> <p>Zadania: 1. Wczytaj sygna\u0142 <code>ekg10.txt</code> i oce\u0144 go wizualnie na wykresie. 2. Wyznacz jego dyskretn\u0105 transformacj\u0119 Fouriera. 3. Wyznacz odwrotn\u0105 dyskretn\u0105 transformacj\u0119 Fouriera ci\u0105gu wyznaczonego w punkcie 2 i por\u00f3wnaj otrzymany ci\u0105g pr\u00f3bek z pierwotnym sygna\u0142em <code>ekg10</code>.</p>"},{"location":"#cwiczenie-4-filtracja-sygnau-ekg","title":"\u0106wiczenie 4: Filtracja sygna\u0142u EKG","text":"<p>Celem \u0107wiczenia jest praktyczne wypr\u00f3bowanie dzia\u0142ania filtr\u00f3w w celu wyeliminowania niepo\u017c\u0105danych zak\u0142\u00f3ce\u0144 z sygna\u0142u EKG.</p> <p>Zadania: 1. Wczytaj sygna\u0142y <code>ekg_noise.txt</code> i zanalizuj zak\u0142\u00f3cenia na sygnale. 2. Zbadaj filtr dolnoprzepustowy na sygnale EKG. 3. Zastosuj filtr g\u00f3rnoprzepustowy na zak\u0142\u00f3conym sygnale. 4. Sporz\u0105d\u017a wykresy sygna\u0142u przed i po filtracji.</p>"},{"location":"#bibliografia","title":"Bibliografia","text":"<ol> <li>Dokumentacja <code>numpy.fft</code>: link</li> <li>Dokumentacja <code>Matplotlib</code>: link</li> <li><code>Scipy.signal</code> dokumentacja: link</li> <li><code>Python</code> Tutorial: link</li> </ol>"},{"location":"ex_1/","title":"Zadanie 1","text":"<p>Napisz skrypt w Pythonie/Matlabie umo\u017cliwiaj\u0105cy wczytywanie i wizualizacj\u0119 badanych sygna\u0142\u00f3w. Program powinien umo\u017cliwia\u0107 obserwowanie wycinka sygna\u0142u dla zadanego przedzia\u0142u czasowego, skalowanie osi wykres\u00f3w i ich opis oraz zapis dowolnego wycinka sygna\u0142u do pliku o podanej nazwie. Sygna\u0142y EKG maj\u0105 format plik\u00f3w tekstowych, w kt\u00f3rych wiersze odpowiadaj\u0105 kolejnym pr\u00f3bkom,  a kolumny kana\u0142om pomiarowym (odprowadzeniom EKG). W niekt\u00f3rych plikach pierwsza kolumna zawiera momenty czasu, a druga zawiera warto\u015bci pr\u00f3bek sygna\u0142u EKG. W takim przypadku pierwsza kolumna s\u0142u\u017cy do skalowania osi  czasu.</p> <p>Kolejne \u0107wiczenia b\u0119d\u0105 polega\u0142y na stopniowym rozbudowywaniu platformy testowej o  nowe funkcjonalno\u015bci. Sprawozdanie powinno obejmowa\u0107 wszystkie \u0107wiczenia z przetwarzania sygna\u0142\u00f3w EKG. Do sprawozdania nale\u017cy do\u0142\u0105czy\u0107 kod. Przy okazji tworzenia sprawozdania warto rozwa\u017cy\u0107 nauczenie si\u0119 i wykorzystanie notatnika  jupyter [2]. Mo\u017cna te\u017c przygotowa\u0107 raport w tradycyjny spos\u00f3b.</p>"},{"location":"ex_1/#platofrma-testowa","title":"Platofrma testowa","text":"<p>Na zdj\u0119ciu znajduje si\u0119 interfejs graficzny aplikacji, kt\u00f3ra s\u0142u\u017cy do analizy i przetwarzania sygna\u0142\u00f3w elektrokardiograficznych (EKG). Aplikacja posiada kilka paneli  z przyciskami i polami tekstowymi umo\u017cliwiaj\u0105cymi u\u017cytkownikowi r\u00f3\u017cne operacje na danych. </p> <p></p>"},{"location":"ex_1/#wyglad-i-funkcjonalnosc-aplikacji","title":"Wygl\u0105d i Funkcjonalno\u015b\u0107 Aplikacji","text":""},{"location":"ex_1/#panel-lewy","title":"Panel Lewy","text":"<ul> <li>Load File (Czerwony przycisk): Umo\u017cliwia u\u017cytkownikowi za\u0142adowanie pliku z danymi EKG z dysku. Klikni\u0119cie tego przycisku otwiera okno dialogowe wyboru pliku.</li> <li>Frequency [Hz]: Pole tekstowe, w kt\u00f3rym u\u017cytkownik mo\u017ce wprowadzi\u0107 cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania danych EKG. Jest to istotne dla p\u00f3\u017aniejszej analizy sygna\u0142u.</li> <li>Start Time [s]: Pole tekstowe do wprowadzenia czasu pocz\u0105tkowego analizy. Umo\u017cliwia u\u017cytkownikowi okre\u015blenie, od kt\u00f3rego momentu sygna\u0142 EKG ma by\u0107 analizowany.</li> <li>End Time [s]: Pole tekstowe do wprowadzenia czasu ko\u0144cowego analizy. Umo\u017cliwia u\u017cytkownikowi okre\u015blenie, do kt\u00f3rego momentu sygna\u0142 EKG ma by\u0107 analizowany.</li> <li>Min Amplitude: Pole tekstowe do wprowadzenia minimalnej amplitudy sygna\u0142u. Mo\u017ce by\u0107 u\u017cywane do filtrowania sygna\u0142u lub ustawiania zakresu wy\u015bwietlania.</li> <li>Max Amplitude: Pole tekstowe do wprowadzenia maksymalnej amplitudy sygna\u0142u. Podobnie jak minimalna amplituda, s\u0142u\u017cy do filtrowania lub ustawiania zakresu wy\u015bwietlania.</li> <li>Save to File (Szary przycisk): Umo\u017cliwia zapisanie przetworzonych danych do pliku. Po klikni\u0119ciu otwiera okno dialogowe, gdzie u\u017cytkownik mo\u017ce wybra\u0107 lokalizacj\u0119 i nazw\u0119 pliku.</li> <li>Show EKG (\u017b\u00f3\u0142ty przycisk): Po klikni\u0119ciu tego przycisku, za\u0142adowany sygna\u0142 EKG jest wy\u015bwietlany na wykresie w centralnej cz\u0119\u015bci interfejsu. Przycisk ten inicjuje proces rysowania wykresu z danymi EKG.</li> </ul>"},{"location":"ex_1/#panel-srodkowy","title":"Panel \u015arodkowy","text":"<ul> <li>Wykres: Obszar, gdzie wy\u015bwietlane s\u0105 dane EKG. Pocz\u0105tkowo jest pusty, ale po za\u0142adowaniu i przetworzeniu danych, sygna\u0142 EKG jest wizualizowany w tym miejscu.</li> </ul>"},{"location":"ex_1/#panel-prawy","title":"Panel Prawy","text":"<ul> <li>Frequency analysis (Pole wyboru): Pozwala u\u017cytkownikowi w\u0142\u0105czy\u0107 lub wy\u0142\u0105czy\u0107 analiz\u0119 cz\u0119stotliwo\u015bciow\u0105 sygna\u0142u EKG.</li> <li>High-Pass Filter (Pole wyboru): Umo\u017cliwia u\u017cytkownikowi w\u0142\u0105czenie filtra g\u00f3rnoprzepustowego. Po zaznaczeniu, pojawiaj\u0105 si\u0119 dodatkowe pola do wprowadzenia parametr\u00f3w filtra:</li> <li>Cut-off Frequency: Pole tekstowe do wprowadzenia cz\u0119stotliwo\u015bci odci\u0119cia filtra.</li> <li>Sampling Frequency: Pole tekstowe do wprowadzenia cz\u0119stotliwo\u015bci pr\u00f3bkowania.</li> <li>Order: Pole tekstowe do wprowadzenia rz\u0119du filtra.</li> <li>Low-Pass Filter (Pole wyboru): Umo\u017cliwia u\u017cytkownikowi w\u0142\u0105czenie filtra dolnoprzepustowego. Po zaznaczeniu, pojawiaj\u0105 si\u0119 dodatkowe pola do wprowadzenia parametr\u00f3w filtra:</li> <li>Cut-off Frequency: Pole tekstowe do wprowadzenia cz\u0119stotliwo\u015bci odci\u0119cia filtra.</li> <li>Sampling Frequency: Pole tekstowe do wprowadzenia cz\u0119stotliwo\u015bci pr\u00f3bkowania.</li> <li>Order: Pole tekstowe do wprowadzenia rz\u0119du filtra.</li> <li>Apply (Szary przycisk): Po ustawieniu odpowiednich parametr\u00f3w filtra, klikni\u0119cie tego przycisku stosuje wybrane filtry do za\u0142adowanego sygna\u0142u EKG.</li> </ul>"},{"location":"ex_1/#panel-dolny","title":"Panel Dolny","text":"<ul> <li>Load Sin (Czerwony przycisk): Umo\u017cliwia za\u0142adowanie sygna\u0142u sinusoidalnego do testowania i por\u00f3wnywania z sygna\u0142em EKG.</li> <li>Load 2 Sin (Czerwony przycisk): Umo\u017cliwia za\u0142adowanie dw\u00f3ch sygna\u0142\u00f3w sinusoidalnych do bardziej z\u0142o\u017conych test\u00f3w.</li> <li>FFT (Zielony przycisk): Przycisk do wykonania szybkiej transformaty Fouriera (FFT) na za\u0142adowanym sygnale, co pozwala na analiz\u0119 cz\u0119stotliwo\u015bciow\u0105 sygna\u0142u.</li> <li>IFFT (Zielony przycisk): Przycisk do wykonania odwrotnej szybkiej transformaty Fouriera (IFFT), co pozwala na odtworzenie oryginalnego sygna\u0142u z jego reprezentacji cz\u0119stotliwo\u015bciowej.</li> <li>Label X: Pole tekstowe do wprowadzenia etykiety osi X wykresu.</li> <li>Label Y: Pole tekstowe do wprowadzenia etykiety osi Y wykresu.</li> </ul>"},{"location":"ex_1/#jak-dziaa-aplikacja","title":"Jak Dzia\u0142a Aplikacja","text":"<p>1) \u0141adowanie Danych: U\u017cytkownik rozpoczyna od za\u0142adowania  pliku z danymi EKG za pomoc\u0105 przycisku \"Load File\". </p> <p></p> <p>2) Konfiguracja Analizy: Nast\u0119pnie mo\u017ce wprowadzi\u0107 odpowiednie  parametry takie jak cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania, czas pocz\u0105tkowy i  ko\u0144cowy analizy, oraz amplitudy minimalne i maksymalne.</p> <p></p> <p>3) Wy\u015bwietlenie Sygna\u0142u: Po wprowadzeniu parametr\u00f3w i  za\u0142adowaniu danych, u\u017cytkownik klika \"Show EKG\" aby  wy\u015bwietli\u0107 sygna\u0142 na wykresie.</p> <p></p> <p>4) Przetwarzanie Sygna\u0142u: U\u017cytkownik mo\u017ce zastosowa\u0107 r\u00f3\u017cne filtry  (g\u00f3rnoprzepustowy, dolnoprzepustowy) poprzez zaznaczenie  odpowiednich opcji i wprowadzenie parametr\u00f3w. Klikni\u0119cie  \"Apply\" stosuje te filtry do sygna\u0142u.</p> <p></p> <p>5) Analiza Cz\u0119stotliwo\u015bciowa: Opcje FFT i IFFT umo\u017cliwiaj\u0105  u\u017cytkownikowi wykonanie analizy cz\u0119stotliwo\u015bciowej sygna\u0142u EKG  oraz odtworzenie sygna\u0142u z tej analizy.</p> <p> </p> <p>Ponadto aplikacja umo\u017cliwia wygenerowanie fali sinusoidalnej oraz  sumy dw\u00f3ch takich fal.</p> <p></p> <p>6) Zapis Danych: Po przetworzeniu i analizie, u\u017cytkownik mo\u017ce zapisa\u0107 wyniki do pliku za pomoc\u0105 przycisku \"Save to File\".</p> <p></p> <p>Aplikacja oferuje intuicyjny interfejs u\u017cytkownika, umo\u017cliwiaj\u0105cy kompleksow\u0105 analiz\u0119 sygna\u0142\u00f3w EKG, co jest przydatne zar\u00f3wno w badaniach naukowych, jak i w praktyce klinicznej.</p>"},{"location":"ex_2/","title":"Zadanie 2","text":""},{"location":"ex_2/#analiza-sygnaow-okresowych-w-dziedzinie-czestotliwosci","title":"Analiza sygna\u0142\u00f3w okresowych w dziedzinie cz\u0119stotliwo\u015bci","text":"<p>Celem \u0107wiczenia jest praktyczne wypr\u00f3bowanie funkcji numpy.fft i numpy.ifft do wyznaczania prostej i odwrotnej transformaty Fouriera [1, 3].</p> <p>1. Wygeneruj ci\u0105g pr\u00f3bek odpowiadaj\u0105cy fali sinusoidalnej o cz\u0119stotliwo\u015bci 50 Hz i d\u0142ugo\u015bci 65536.</p> <p></p> <p>2. Wyznacz dyskretn\u0105 transformat\u0119 Fouriera tego sygna\u0142u i przedstaw jego widmo amplitudowe na wykresie w zakresie cz\u0119stotliwo\u015bci [0, fs/2], gdzie fs oznacza cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania.</p> <p></p> <p>3. Wygeneruj ci\u0105g pr\u00f3bek mieszaniny dw\u00f3ch fal sinusoidalnych (tzn. ich kombinacji liniowej) o cz\u0119stotliwo\u015bciach 50 i 60 Hz. Wykonaj zadanie z punktu 2 dla tego sygna\u0142u.</p> <p></p> <p></p> <p>4. Powt\u00f3rz eksperymenty dla r\u00f3\u017cnych czas\u00f3w trwania sygna\u0142\u00f3w, tzn. dla r\u00f3\u017cnych cz\u0119stotliwo\u015bci pr\u00f3bkowania.</p> <p></p> <p>Wykresy przedstawiaj\u0105 widmo amplitudowe sygna\u0142u b\u0119d\u0105cego mieszanin\u0105 dw\u00f3ch cz\u0119stotliwo\u015bci: 50 Hz i 60 Hz, dla r\u00f3\u017cnych cz\u0119stotliwo\u015bci pr\u00f3bkowania (fs). </p> <p>Widmo amplitudowe dla fs = 500 Hz pokazuje dwa wyra\u017ane  piki przy 50 Hz i 60 Hz, co odpowiada cz\u0119stotliwo\u015bciom sk\u0142adowym sygna\u0142u. Amplituda dla obu  cz\u0119stotliwo\u015bci wynosi oko\u0142o 0,8 dla 50 Hz i 1,0 dla 60 Hz. </p> <p>W przypadku fs = 2000 Hz, podobnie  jak wcze\u015bniej, widoczne s\u0105 dwa piki przy 50 Hz i 60 Hz, z amplitudami rz\u0119du 0,8 dla 50 Hz i 1,0  dla 60 Hz. Dla fs = 4000 Hz, piki przy 50 Hz i 60 Hz s\u0105 wyra\u017ane i dobrze zdefiniowane, a amplitudy  s\u0105 podobne do poprzednich przypadk\u00f3w, wynosz\u0105c oko\u0142o 0,8 dla 50 Hz i 1,0 dla 60 Hz. </p> <p>We wszystkich przypadkach widmo amplitudowe dok\u0142adnie przedstawia cz\u0119stotliwo\u015bci sk\u0142adowe sygna\u0142u, niezale\u017cnie od cz\u0119stotliwo\u015bci pr\u00f3bkowania. Przy wy\u017cszych cz\u0119stotliwo\u015bciach pr\u00f3bkowania wykresy s\u0105 bardziej szczeg\u00f3\u0142owe, co mo\u017ce by\u0107 korzystne dla dok\u0142adnej analizy sygna\u0142\u00f3w. Wykresy pokazuj\u0105, \u017ce sygna\u0142 zawiera dwie sk\u0142adowe harmoniczne o cz\u0119stotliwo\u015bciach 50 Hz i 60 Hz.</p> <p>5. Wyznacz odwrotne transformaty Fouriera ci\u0105g\u00f3w wyznaczonych w zadaniu 2 i por\u00f3wnaj z ci\u0105gami oryginalnymi.</p> <p></p> <p>Powy\u017csze ykresy przedstawiaj\u0105 por\u00f3wnanie mi\u0119dzy oryginalnym sygna\u0142em sinusoidalnym a sygna\u0142em zrekonstruowanym za pomoc\u0105 odwrotnej dyskretnej transformaty Fouriera (IDFT). Oryginalny sygna\u0142 ma cz\u0119stotliwo\u015b\u0107 60 Hz, a jego amplituda oscyluje p\u0142ynnie mi\u0119dzy -1 a 1. Wykres pokazuje okresowy przebieg fali, kt\u00f3ry jest jednolity na przestrzeni 0,5 sekundy. </p> <p>Zrekonstruowany sygna\u0142 zosta\u0142 odtworzony po zastosowaniu IDFT na oryginalnym sygnale. Jego amplituda  i kszta\u0142t fali s\u0105 prawie identyczne z oryginalnym sygna\u0142em, co dowodzi, \u017ce transformacja i jej odwrotno\u015b\u0107 zosta\u0142y wykonane poprawnie. Linia przerywana na wykresie zrekonstruowanego sygna\u0142u wskazuje, \u017ce jest to wynik IDFT, ale jego przebieg i warto\u015bci s\u0105 praktycznie takie same jak w oryginale. </p> <p>W skr\u00f3cie, wykresy pokazuj\u0105, \u017ce zar\u00f3wno oryginalny, jak i zrekonstruowany sygna\u0142 maj\u0105 t\u0119 sam\u0105 struktur\u0119, co potwierdza dok\u0142adno\u015b\u0107 przeprowadzonych operacji transformacji i odwrotnej transformacji Fouriera.</p>"},{"location":"ex_3/","title":"Zadanie 3","text":"<p>Analiza sygna\u0142u EKG w dziedzinie cz\u0119stotliwo\u015bci</p> <p>Celem \u0107wiczenia jest obserwacja widma sygna\u0142u EKG.</p> <p>1) Wczyta\u0107 sygna\u0142 ekg100.txt i oceni\u0107 go wizualnie na wykresie</p> <p></p> <p>Na za\u0142\u0105czonym wykresie EKG wida\u0107 dane sygna\u0142owe, kt\u00f3re zosta\u0142y za\u0142adowane do aplikacji.  O\u015b X reprezentuje czas w sekundach, od 1 do 5 sekund, natomiast o\u015b Y przedstawia  amplitud\u0119 sygna\u0142u EKG, z zakresem od -0.7 do 1. Skala jest odpowiednio dobrana,  umo\u017cliwiaj\u0105c wyra\u017an\u0105 obserwacj\u0119 charakterystyki sygna\u0142u.</p> <p>Sygna\u0142 EKG jest wyra\u017any, z dobrze widocznymi za\u0142amkami QRS, co jest kluczowe dla  analizy rytmu serca. Amplituda za\u0142amk\u00f3w jest znacznie wi\u0119ksza ni\u017c innych cz\u0119\u015bci  sygna\u0142u, co jest typowe dla tego typu sygna\u0142\u00f3w. W sygnale nie wida\u0107 znacz\u0105cych szum\u00f3w  ani artefakt\u00f3w, co sugeruje, \u017ce dane s\u0105 dobrze przefiltrowane lub pochodz\u0105 z czystego \u017ar\u00f3d\u0142a.</p> <p>Wykres EKG wydaje si\u0119 by\u0107 poprawny, z wyra\u017anymi za\u0142amkami QRS i minimalnymi szumami.  Cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania i zakres czasowy s\u0105 odpowiednie, a parametry wykresu  dobrze dobrane do wizualnej analizy sygna\u0142u EKG. </p> <p>2) Wyznaczy\u0107 jego dyskretn\u0105 transformat\u0119 Fouriera i przedstawi\u0107 widmo amplitudowe  sygna\u0142u w funkcji cz\u0119stotliwo\u015bci w zakresie [0, fs/2], gdzie fs oznacza cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania.</p> <p></p> <p>Powy\u017cszy wykres przedstawia widmo amplitudowe sygna\u0142u EKG, gdzie o\u015b pozioma pokazuje cz\u0119stotliwo\u015bci w hercach (Hz), a o\u015b pionowa reprezentuje amplitudy. Widmo amplitudowe sygna\u0142u EKG przedstawia rozk\u0142ad cz\u0119stotliwo\u015bciowy sygna\u0142u, czyli pokazuje,  jakie sk\u0142adowe cz\u0119stotliwo\u015bciowe s\u0105 obecne w sygnale i z jak\u0105 amplitud\u0105. </p> <p>Na wykresie widzimy,  \u017ce najwi\u0119ksze amplitudy znajduj\u0105 si\u0119 w niskich cz\u0119stotliwo\u015bciach (poni\u017cej 20 Hz). Jest to  zgodne z charakterystyk\u0105 sygna\u0142u EKG, poniewa\u017c wi\u0119kszo\u015b\u0107 energii sygna\u0142u EKG skupiona jest  w przedziale od 0.05 Hz do 40 Hz. Najwa\u017cniejsze sk\u0142adowe, takie jak za\u0142amki P, QRS, i T,  maj\u0105 najwi\u0119ksz\u0105 energi\u0119 w tych cz\u0119stotliwo\u015bciach. </p> <p>W okolicach 0 Hz widzimy bardzo wysoki pik,  co mo\u017ce wskazywa\u0107 na obecno\u015b\u0107 sk\u0142adowej sta\u0142ej w sygnale. Jest to normalne w przypadku sygna\u0142\u00f3w  EKG, poniewa\u017c mog\u0105 zawiera\u0107 pewne przesuni\u0119cie DC (sk\u0142adowa sta\u0142a), kt\u00f3re nie niesie u\u017cytecznej  informacji diagnostycznej, ale jest efektem nieidealnego sprz\u0119tu pomiarowego lub innych \u017ar\u00f3de\u0142  zak\u0142\u00f3ce\u0144. </p> <p>Amplituda sk\u0142adowych cz\u0119stotliwo\u015bciowych powy\u017cej 50 Hz jest znacznie mniejsza, co  r\u00f3wnie\u017c jest typowe dla sygna\u0142\u00f3w EKG. W rzeczywisto\u015bci sygna\u0142y EKG s\u0105 zwykle filtrowane w  celu usuni\u0119cia sk\u0142adowych o cz\u0119stotliwo\u015bciach powy\u017cej 50-60 Hz, kt\u00f3re mog\u0105 by\u0107 wynikiem  zak\u0142\u00f3ce\u0144 elektromagnetycznych (np. z sieci elektrycznej). </p> <p>Widoczne s\u0105 pojedyncze piki w okolicach  60 Hz, co mo\u017ce by\u0107 wynikiem interferencji sieci elektrycznej. Jest to cz\u0119sty problem w  nagraniach EKG i cz\u0119sto stosuje si\u0119 filtry do eliminacji tych zak\u0142\u00f3ce\u0144.</p> <p>3) Wyznaczy\u0107 odwrotn\u0105 dyskretn\u0105 transformat\u0119 Fouriera ci\u0105gu wyznaczonego w punkcie 2 i por\u00f3wna\u0107 otrzymany ci\u0105g pr\u00f3bek z pierwotnym sygna\u0142em ekg100 (mo\u017cna wyznaczy\u0107 r\u00f3\u017cnic\u0119 sygna\u0142\u00f3w)</p> <p></p> <p>Po zastosowaniu odwrotnej transformaty Fouriera (IDFT) do sygna\u0142u EKG, otrzymany sygna\u0142 jest bardzo  zbli\u017cony do oryginalnego. G\u0142\u00f3wne cechy sygna\u0142u, takie jak piki i doliny, kt\u00f3re odpowiadaj\u0105 zespo\u0142om  QRS, falom P i T w typowym sygnale EKG, s\u0105 dobrze zachowane. To oznacza, \u017ce transformata Fouriera  i jej odwrotno\u015b\u0107 skutecznie zachowuj\u0105 krytyczne elementy sygna\u0142u EKG niezb\u0119dne do diagnostyki.</p> <p>Linia bazowa w sygnale zrekonstruowanym jest zgodna z oryginalnym sygna\u0142em,  bez znacz\u0105cych przesuni\u0119\u0107. Amplituda pik\u00f3w w zrekonstruowanym sygnale jest r\u00f3wnie\u017c zgodna z  orygina\u0142em, co oznacza, \u017ce intensywno\u015b\u0107 sygna\u0142u zosta\u0142a zachowana.</p> <p>Komponenty wysokiej cz\u0119stotliwo\u015bci zosta\u0142y dobrze zachowane, co jest kluczowe dla uchwycenia  szybkich zmian w sygnale, takich jak strome wzrosty i spadki zespo\u0142u QRS.</p> <p></p> <p>Wykres r\u00f3\u017cnicy mi\u0119dzy oryginalnym sygna\u0142em EKG a odwrotn\u0105 transformat\u0105 Fouriera (IDFT) sygna\u0142u  dostarcza istotnych informacji w kontek\u015bcie analizy EKG. Po pierwsze, dok\u0142adno\u015b\u0107 rekonstrukcji:  w idealnym przypadku r\u00f3\u017cnica powinna wynosi\u0107 zero, co oznacza, \u017ce IDFT doskonale odwzorowuje  oryginalny sygna\u0142. W praktyce mog\u0105 wyst\u0119powa\u0107 niewielkie r\u00f3\u017cnice z powodu b\u0142\u0119d\u00f3w numerycznych  i obci\u0119cia wy\u017cszych cz\u0119stotliwo\u015bci. Znaczne odchylenia mog\u0105 wskazywa\u0107 na obecno\u015b\u0107 szum\u00f3w lub  artefakt\u00f3w, kt\u00f3re nie zosta\u0142y idealnie odwzorowane. Niski poziom r\u00f3\u017cnic sugeruje, \u017ce sygna\u0142  jest stosunkowo czysty i procesy transformacji Fouriera dok\u0142adnie odwzorowuj\u0105 sygna\u0142.</p> <p>Transformata Fouriera dzia\u0142a r\u00f3wnie\u017c jako filtr, potencjalnie wyg\u0142adzaj\u0105c pewne szumy,  jednocze\u015bnie redukuj\u0105c komponenty o wysokiej cz\u0119stotliwo\u015bci. Wykres r\u00f3\u017cnicy mo\u017ce pokazywa\u0107 efekt netto tego filtrowania. Je\u015bli pewne szumy o wysokiej cz\u0119stotliwo\u015bci s\u0105 redukowane,  mo\u017ce to by\u0107 korzystne dla wyra\u017aniejszej interpretacji sygna\u0142u.</p>"},{"location":"ex_4/","title":"Zadanie 4","text":""},{"location":"ex_4/#filtracja-sygnau-ekg","title":"Filtracja sygna\u0142u EKG","text":"<p>\u0106wiczenie 4. Celem \u0107wiczenia jest praktyczne wypr\u00f3bowanie dzia\u0142ania filtr\u00f3w w celu wyeliminowania niepo\u017c\u0105danych zak\u0142\u00f3ce\u0144 z sygna\u0142u EKG. Prosz\u0119 wybra\u0107 rodzaj filtra do eksperymentowania, np. Butterwortha lub Czebyszewa. Do filtracji wykorzysta\u0107 gotowe funkcje z biblioteki scipy.signal [7]. Biblioteka posiada r\u00f3wnie\u017c funkcje wspomagaj\u0105ce projektowanie filtr\u00f3w, kt\u00f3re mo\u017cna zastosowa\u0107.</p> <p>1) Wczytaj sygna\u0142 ekg noise.txt i zauwa\u017c zak\u0142\u00f3cenia na\u0142o\u017cone na sygna\u0142. Wykre\u015bli\u0107 cz\u0119stotliwo\u015bciow\u0105 charakterystyk\u0119 amplitudow\u0105 sygna\u0142u.</p> <p></p> <p>Powy\u017cszy wykres przedstawia sygna\u0142 EKG z na\u0142o\u017conymi zak\u0142\u00f3ceniami. Charakterystyczne  piki sygna\u0142u reprezentuj\u0105 poszczeg\u00f3lne fazy cyklu serca, takie jak za\u0142amek P, kompleks QRS i za\u0142amek T.</p> <p>Sygna\u0142 powinien mie\u0107 stosunkowo g\u0142adki przebieg, z wyra\u017anymi, ale kr\u00f3tkotrwa\u0142ymi pikami odpowiadaj\u0105cymi aktywno\u015bci elektrycznej serca. Zak\u0142\u00f3cenia w sygnale mo\u017cna zauwa\u017cy\u0107 jako drobne oscylacje i nier\u00f3wno\u015bci  w miejscach, gdzie sygna\u0142 powinien by\u0107 wzgl\u0119dnie p\u0142aski.</p> <p>Takie zak\u0142\u00f3cenia mog\u0105 pochodzi\u0107 z r\u00f3\u017cnych  \u017ar\u00f3de\u0142, takich jak szum elektryczny, kt\u00f3ry mo\u017ce by\u0107 spowodowany przez zak\u0142\u00f3cenia pochodz\u0105ce z innych  urz\u0105dze\u0144 elektronicznych w pobli\u017cu aparatury EKG, ruch pacjenta, czyli artefakty ruchowe powstaj\u0105ce, gdy pacjent porusza si\u0119 podczas pomiaru, co powoduje zak\u0142\u00f3cenia mechaniczne, oraz szum t\u0142a, kt\u00f3ry mo\u017ce pochodzi\u0107 z otoczenia, na przyk\u0142ad z przewod\u00f3w zasilaj\u0105cych lub innych \u017ar\u00f3de\u0142 elektromagnetycznych.</p> <p>Na wykresie wida\u0107 szum t\u0142a jako drobne, ci\u0105g\u0142e oscylacje na ca\u0142ej d\u0142ugo\u015bci sygna\u0142u, kt\u00f3re zak\u0142\u00f3caj\u0105 w\u0142a\u015bciwy przebieg sygna\u0142u EKG. Widoczne s\u0105 r\u00f3wnie\u017c du\u017ce skoki (artefakty), kt\u00f3re nie s\u0105 cz\u0119\u015bci\u0105 typowego sygna\u0142u EKG i mog\u0105 wynika\u0107 z nag\u0142ych ruch\u00f3w lub zak\u0142\u00f3ce\u0144 elektromagnetycznych.</p> <p></p> <p>Powy\u017cszy wykres przedstawia analiz\u0119 cz\u0119stotliwo\u015bciow\u0105 sygna\u0142u EKG z zak\u0142\u00f3ceniami. Na osi poziomej (X)  przedstawione s\u0105 cz\u0119stotliwo\u015bci w Hz, a na osi pionowej (Y) amplituda.</p> <p>Wida\u0107 g\u0142\u00f3wny pik na bardzo  niskiej cz\u0119stotliwo\u015bci (blisko 0 Hz), co wskazuje na du\u017c\u0105 sk\u0142adow\u0105 sta\u0142\u0105 lub bardzo wolno zmieniaj\u0105ce  si\u0119 sygna\u0142y, typowe dla EKG. </p> <p>W zakresie niskich cz\u0119stotliwo\u015bci (od 0 Hz do oko\u0142o 50 Hz) widoczne s\u0105  oscylacje, kt\u00f3re mog\u0105 odpowiada\u0107 szumowi i zak\u0142\u00f3ceniom pochodz\u0105cym z r\u00f3\u017cnych \u017ar\u00f3de\u0142, takich jak  szumy elektryczne czy artefakty ruchowe. </p> <p>Wyra\u017any pik przy oko\u0142o 50 Hz prawdopodobnie odpowiada  zak\u0142\u00f3ceniom od sieci zasilaj\u0105cej. </p> <p>Powy\u017cej 50 Hz amplituda sygna\u0142u jest bardzo niska, co oznacza,  \u017ce wi\u0119kszo\u015b\u0107 energii sygna\u0142u skoncentrowana jest w niskich cz\u0119stotliwo\u015bciach.</p> <p>2) Zbadaj filtr dolnoprzepustowy o cz\u0119stotliwo\u015bci granicznej 60 Hz w celu redukcji zak\u0142\u00f3ce\u0144 pochodz\u0105cych z sieci zasilaj\u0105cej. Wyznacz parametry filtra, wykre\u015bl jego charakterystyk\u0119 (zale\u017cno\u015b\u0107 t\u0142umienia od cz\u0119stotliwo\u015bci), przebieg sygna\u0142u po filtracji oraz jego widmo. Mo\u017cna te\u017c wyznaczy\u0107 r\u00f3\u017cnic\u0119 mi\u0119dzy sygna\u0142em przed i po filtracji i widmo tej r\u00f3\u017cnicy.</p> <p></p> <p>Na za\u0142\u0105czonym obrazie widoczny jest sygna\u0142 EKG po zastosowaniu filtra dolnoprzepustowego o  nast\u0119puj\u0105cych parametrach: cz\u0119stotliwo\u015b\u0107 odci\u0119cia (cut-off) wynosi 60 Hz, cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania  (fs) to 360 Hz, a rz\u0105d filtra (order) wynosi 6. </p> <p>Filtr dolnoprzepustowy skutecznie t\u0142umi sk\u0142adowe sygna\u0142u powy\u017cej 60 Hz, co redukuje wysokocz\u0119stotliwo\u015bciowe zak\u0142\u00f3cenia, takie jak szumy z sieci zasilaj\u0105cej, i pozwala na uzyskanie bardziej przejrzystego sygna\u0142u EKG do dalszej analizy.</p> <p></p> <p>Wykres przedstawia charakterystyk\u0119 cz\u0119stotliwo\u015bciow\u0105 filtru dolnoprzepustowego, kt\u00f3ry ma za zadanie t\u0142umienie zak\u0142\u00f3ce\u0144 w sygnale EKG. O\u015b pozioma (x) ilustruje cz\u0119stotliwo\u015b\u0107 w hercach (Hz).  O\u015b pionowa (y) przedstawia t\u0142umienie amplitudy w decybelach (dB), co jest logarytmiczn\u0105 miar\u0105 pokazuj\u0105c\u0105, jak bardzo sygna\u0142 jest t\u0142umiony przez filtr.</p> <p>Zielona linia na wykresie pokazuje, jak filtr dzia\u0142a w zakresie r\u00f3\u017cnych cz\u0119stotliwo\u015bci. Do oko\u0142o  60 Hz t\u0142umienie jest minimalne, co oznacza, \u017ce sygna\u0142y o tych cz\u0119stotliwo\u015bciach przechodz\u0105 przez filtr bez wi\u0119kszych zmian. Jest to zakres, w kt\u00f3rym filtr pozwala na swobodne przej\u015bcie sygna\u0142u. </p> <p>Przy oko\u0142o 60 Hz zaczyna si\u0119 gwa\u0142towny wzrost t\u0142umienia, co oznacza, \u017ce filtr zaczyna znacz\u0105co t\u0142umi\u0107 sygna\u0142y powy\u017cej tej cz\u0119stotliwo\u015bci. Powy\u017cej 60 Hz t\u0142umienie szybko ro\u015bnie, osi\u0105gaj\u0105c wysokie warto\u015bci, co wskazuje, \u017ce filtr skutecznie usuwa zak\u0142\u00f3cenia o wy\u017cszych cz\u0119stotliwo\u015bciach,  takich jak zak\u0142\u00f3cenia z sieci zasilaj\u0105cej (typowo 50/60 Hz).</p> <p></p> <p>Wykres przedstawia widmo sygna\u0142u oryginalnego i widmo sygna\u0142u po filtracji, ograniczone do zakresu cz\u0119stotliwo\u015bci 0-100 Hz. Na osi poziomej (x) znajduj\u0105 si\u0119 cz\u0119stotliwo\u015bci w hercach (Hz), a na osi pionowej (y) moc spektralna w skali logarytmicznej (dB).</p> <p>Niebieska linia reprezentuje widmo sygna\u0142u oryginalnego. Wida\u0107, \u017ce sygna\u0142 ma istotne sk\u0142adowe w ca\u0142ym zakresie cz\u0119stotliwo\u015bci, szczeg\u00f3lnie powy\u017cej 60 Hz, gdzie widoczne s\u0105 szczyty mocy spektralnej. Te szczyty s\u0105 wynikami zak\u0142\u00f3ce\u0144, prawdopodobnie pochodz\u0105cych z sieci zasilaj\u0105cej lub innych \u017ar\u00f3de\u0142 wysokocz\u0119stotliwo\u015bciowych zak\u0142\u00f3ce\u0144.</p> <p>Czerwona linia pokazuje widmo sygna\u0142u po filtracji dolnoprzepustowej. Filtr zosta\u0142 u\u017cyty  z cz\u0119stotliwo\u015bci\u0105 odci\u0119cia 60 Hz, co oznacza, \u017ce skutecznie t\u0142umi sk\u0142adowe sygna\u0142u powy\u017cej tej  cz\u0119stotliwo\u015bci. Na wykresie wida\u0107, \u017ce po filtracji moc spektralna powy\u017cej 60 Hz jest znacznie ni\u017csza. Sk\u0142adowe powy\u017cej 60 Hz zosta\u0142y znacznie st\u0142umione, co \u015bwiadczy o skuteczno\u015bci filtru w  usuwaniu zak\u0142\u00f3ce\u0144 wysokocz\u0119stotliwo\u015bciowych.</p> <p>W zakresie cz\u0119stotliwo\u015bci do 60 Hz, zar\u00f3wno w sygnale oryginalnym, jak i przefiltrowanym widoczne  s\u0105 sk\u0142adowe sygna\u0142u. Warto\u015bci mocy spektralnej w tym zakresie s\u0105 podobne dla obu sygna\u0142\u00f3w, co  wskazuje, \u017ce filtr dolnoprzepustowy nie zmienia istotnie sk\u0142adowych sygna\u0142u w tym zakresie.  W zakresie cz\u0119stotliwo\u015bci powy\u017cej 60 Hz widmo sygna\u0142u oryginalnego pokazuje znacz\u0105ce sk\u0142adowe, kt\u00f3re s\u0105 efektem zak\u0142\u00f3ce\u0144. Po filtracji, te sk\u0142adowe s\u0105 znacznie zredukowane. Moc spektralna powy\u017cej 60 Hz w sygnale przefiltrowanym jest znacznie ni\u017csza, co potwierdza, \u017ce filtr skutecznie usuwa  zak\u0142\u00f3cenia.</p> <p>Wykres wyra\u017anie pokazuje, \u017ce filtr dolnoprzepustowy z cz\u0119stotliwo\u015bci\u0105 odci\u0119cia 60 Hz skutecznie t\u0142umi zak\u0142\u00f3cenia powy\u017cej tej cz\u0119stotliwo\u015bci. Dzi\u0119ki temu, sygna\u0142 EKG po filtracji jest czystszy, co u\u0142atwia jego analiz\u0119 i interpretacj\u0119. Filtr zachowuje sk\u0142adowe sygna\u0142u poni\u017cej 60 Hz, co jest kluczowe dla prawid\u0142owej analizy danych EKG.</p> <p>3) Zastosuj nast\u0119pnie, do sygna\u0142u otrzymanego w punkcie 2, filtr g\u00f3rnoprzepustowy o cz\u0119stotliwo\u015bci granicznej 5 Hz w celu eliminacji p\u0142ywania linii izoelektrycznej. Sporz\u0105d\u017a wykresy sygna\u0142\u00f3w jak w punkcie 2. Zauwa\u017c, \u017ce wykonuj\u0105c polecenia 2 i 3 dostali\u015bmy szeregowe po\u0142\u0105czenie filtr\u00f3w odpowiednio dolno- i g\u00f3rnoprzepustowego, co jest r\u00f3wnowa\u017cne zastosowaniu filtra pasmowoprzepustowego o pa\u015bmie przepustowym [5, 60] Hz</p> <p></p> <p>Na za\u0142\u0105czonym obrazie widoczny jest sygna\u0142 EKG po zastosowaniu filtra g\u00f3rnoprzepustowego o  nast\u0119puj\u0105cych parametrach: cz\u0119stotliwo\u015b\u0107 odci\u0119cia (cut-off) wynosi 5 Hz, cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania (fs) to 360 Hz, a rz\u0105d filtra (order) wynosi 6.</p> <p>Filtr g\u00f3rnoprzepustowy skutecznie t\u0142umi sk\u0142adowe sygna\u0142u poni\u017cej 5 Hz, co eliminuje  niskocz\u0119stotliwo\u015bciowe zak\u0142\u00f3cenia, takie jak p\u0142ywanie linii izoelektrycznej, i pozwala  na uzyskanie bardziej przejrzystego sygna\u0142u EKG do dalszej analizy.</p> <p></p> <p>Wykres przedstawia charakterystyk\u0119 cz\u0119stotliwo\u015bciow\u0105 filtru po\u0142\u0105czonego, sk\u0142adaj\u0105cego si\u0119 z  filtru dolnoprzepustowego (o cz\u0119stotliwo\u015bci odci\u0119cia 60 Hz) oraz filtru g\u00f3rnoprzepustowego (o cz\u0119stotliwo\u015bci odci\u0119cia 5 Hz).</p> <p>W zakresie cz\u0119stotliwo\u015bci poni\u017cej 5 Hz, filtr wykazuje wysokie t\u0142umienie, co oznacza, \u017ce  sk\u0142adowe sygna\u0142u w tym zakresie s\u0105 skutecznie t\u0142umione. Jest to efekt dzia\u0142ania filtru  g\u00f3rnoprzepustowego, kt\u00f3ry eliminuje niskocz\u0119stotliwo\u015bciowe zak\u0142\u00f3cenia, takie jak p\u0142ywanie linii izoelektrycznej.</p> <p>Powy\u017cej 60 Hz r\u00f3wnie\u017c obserwujemy wysokie t\u0142umienie, co jest wynikiem dzia\u0142ania filtru  dolnoprzepustowego. Ten filtr t\u0142umi sk\u0142adowe sygna\u0142u powy\u017cej tej cz\u0119stotliwo\u015bci, skutecznie  usuwaj\u0105c zak\u0142\u00f3cenia wysokocz\u0119stotliwo\u015bciowe, takie jak szumy z sieci zasilaj\u0105cej.</p> <p>W zakresie od 5 Hz do 60 Hz filtr przepuszcza sk\u0142adowe sygna\u0142u z minimalnym t\u0142umieniem.  Jest to pasmo, w kt\u00f3rym sygna\u0142y przechodz\u0105 przez filtr bez wi\u0119kszych zmian, co jest istotne  dla analizy sygna\u0142u EKG, kt\u00f3ry zawiera wa\u017cne informacje diagnostyczne w tym zakresie cz\u0119stotliwo\u015bci.</p> <p></p> <p>Wykres przedstawia widmo sygna\u0142u oryginalnego (niebieska linia) oraz widmo sygna\u0142u po  filtracji dolnoprzepustowej i g\u00f3rnoprzepustowej (zielona linia).</p> <p>Widmo sygna\u0142u oryginalnego ukazuje sk\u0142adowe w ca\u0142ym zakresie cz\u0119stotliwo\u015bci od 0 do 100 Hz,  z wyra\u017anymi zak\u0142\u00f3ceniami niskocz\u0119stotliwo\u015bciowymi poni\u017cej 5 Hz oraz wysokocz\u0119stotliwo\u015bciowymi powy\u017cej 60 Hz, kt\u00f3re s\u0105 widoczne jako wy\u017csze warto\u015bci mocy spektralnej.  Po zastosowaniu filtracji, widmo sygna\u0142u po filtracji wykazuje skuteczne zredukowanie  zak\u0142\u00f3ce\u0144 niskocz\u0119stotliwo\u015bciowych poni\u017cej 5 Hz dzi\u0119ki filtrowi g\u00f3rnoprzepustowemu oraz znacz\u0105ce t\u0142umienie sk\u0142adowych powy\u017cej 60 Hz, co jest efektem dzia\u0142ania filtru dolnoprzepustowego.</p> <p>Sk\u0142adowe sygna\u0142u w zakresie od 5 Hz do 60 Hz s\u0105 zachowane, co jest kluczowe dla analizy EKG. Wynikowy sygna\u0142 po filtracji jest oczyszczony z zak\u0142\u00f3ce\u0144, co umo\u017cliwia uzyskanie bardziej przejrzystych danych do analizy medycznej. Por\u00f3wnanie obu widm pokazuje, jak skutecznie  filtry usun\u0119\u0142y niepo\u017c\u0105dane zak\u0142\u00f3cenia.</p> <p>Warto zauwa\u017cy\u0107, \u017ce zastosowanie filtr\u00f3w dolnoprzepustowego i g\u00f3rnoprzepustowego w  kolejnych etapach filtracji jest r\u00f3wnowa\u017cne zastosowaniu filtra pasmowoprzepustowego o pa\u015bmie przepustowym [5, 60] Hz. Taki filtr pasmowoprzepustowy przepuszcza sygna\u0142y mieszcz\u0105ce  si\u0119 w tym zakresie cz\u0119stotliwo\u015bci, skutecznie eliminuj\u0105c zak\u0142\u00f3cenia zar\u00f3wno niskocz\u0119stotliwo\u015bciowe  (poni\u017cej 5 Hz), jak i wysokocz\u0119stotliwo\u015bciowe (powy\u017cej 60 Hz). </p> <p>Dzi\u0119ki temu oczyszczony sygna\u0142 EKG  zawiera tylko te sk\u0142adowe, kt\u00f3re s\u0105 istotne dla diagnozy i analizy medycznej, co znacz\u0105co poprawia jego jako\u015b\u0107 i u\u017cyteczno\u015b\u0107. Por\u00f3wnanie obu widm pokazuje, jak skutecznie filtry usun\u0119\u0142y niepo\u017c\u0105dane zak\u0142\u00f3cenia, pozostawiaj\u0105c tylko po\u017c\u0105dane sk\u0142adowe sygna\u0142u.</p>"},{"location":"readFile/","title":"Wczytywanie sygna\u0142u","text":""},{"location":"readFile/#wczytywanie-sygnau-ekg","title":"Wczytywanie sygna\u0142u EKG","text":"<p>U\u017cyte metody i funkcje s\u0142u\u017c\u0105 do wczytywania sygna\u0142u EKG z pliku tekstowego i jego przetwarzania  w celu analizy sygna\u0142u. Podczas inicjalizacji, klasa <code>File</code> przyjmuje \u015bcie\u017ck\u0119 do pliku oraz cz\u0119stotliwo\u015b\u0107  pr\u00f3bkowania sygna\u0142u. Nast\u0119pnie, za pomoc\u0105 odpowiednich metod, wczytuje dane z pliku, przetwarza je,  generuj\u0105c tablice czasowe oraz sygna\u0142owe, co umo\u017cliwia dalsz\u0105 analiz\u0119 i interpretacj\u0119 sygna\u0142u EKG.</p>"},{"location":"readFile/#metody","title":"Metody","text":""},{"location":"readFile/#konstruktor-klasy-file","title":"Konstruktor klasy File","text":"<p>Metoda inicjalizacyjna <code>__init__</code> dla klasy File przyjmuje dwa argumenty: <code>path</code> oraz <code>frequency</code>. Wewn\u0105trz metody warto\u015bci te s\u0105 przypisywane odpowiednio do atrybut\u00f3w <code>self.path</code> i <code>self.frequency</code>. Dzi\u0119ki temu, gdy tworzony jest obiekt tej klasy, jego atrybuty <code>path</code> i <code>frequency</code> s\u0105 ustawiane na warto\u015bci przekazane podczas inicjalizacji.</p> <pre><code>def __init__(self, path, frequency):\n    self.path = path\n    self.frequency = frequency\n</code></pre>"},{"location":"readFile/#parametry","title":"Parametry","text":"<ul> <li>path: <code>str</code>   \u015acie\u017cka do pliku z sygna\u0142em EKG.</li> <li>frequency: <code>float</code>   Cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania sygna\u0142u EKG.</li> </ul>"},{"location":"readFile/#wczytywanie-sygnau-ekg-z-pliku","title":"Wczytywanie sygna\u0142u EKG z pliku","text":"<p>Funkcja <code>load_EKG</code> wczytuje dane z pliku EKG i przetwarza je na sygna\u0142 oraz odpowiadaj\u0105cy mu czas. Najpierw u\u017cywa <code>np.genfromtxt</code> do wczytania danych z pliku, kt\u00f3rego \u015bcie\u017cka jest zapisana w <code>self.path</code>. Nast\u0119pnie sprawdza wymiar danych. Je\u015bli dane s\u0105 dwuwymiarowe i maj\u0105 wi\u0119cej ni\u017c jedn\u0105 kolumn\u0119, generuje czas jako tablic\u0119 r\u00f3wnomiernie roz\u0142o\u017conych punkt\u00f3w i przypisuje dane do zmiennej <code>signal</code>. Je\u015bli dane dwuwymiarowe maj\u0105 tylko jedn\u0105 kolumn\u0119, przypisuje pierwsz\u0105 kolumn\u0119 do <code>time</code>, a drug\u0105 do <code>signal</code>. Je\u015bli dane s\u0105 jednowymiarowe, generuje czas jako tablic\u0119 r\u00f3wnomiernie roz\u0142o\u017conych punkt\u00f3w i przypisuje dane do <code>signal</code>. Na koniec funkcja zwraca dwie tablice: <code>time</code> i <code>signal</code>.</p> <pre><code>def load_EKG(self):\n    data = np.genfromtxt(self.path)\n    if data.ndim == 2:  # File has 2 dimensions\n        if data.shape[1] &gt; 2:  # File has more than 1 column\n            time = np.arange(len(data)) / self.frequency\n            signal = data\n        else:  # File has only 1 column\n            time = data[:, 0]\n            signal = data[:, 1]\n    else:  # File has only 1 dimension\n        time = np.arange(len(data)) / self.frequency\n        signal = data\n\n    return time, signal\n</code></pre>"},{"location":"readFile/#zwraca","title":"Zwraca","text":"<ul> <li>time: <code>numpy.ndarray</code>   Tablica czas\u00f3w, obliczona na podstawie cz\u0119stotliwo\u015bci pr\u00f3bkowania.</li> <li>signal: <code>numpy.ndarray</code>   Tablica warto\u015bci sygna\u0142u EKG.</li> </ul>"},{"location":"readFile/#obsuga-sygnau-ekg","title":"Obs\u0142uga sygna\u0142u EKG","text":"<p>Funkcja otwiera okno dialogowe umo\u017cliwiaj\u0105ce u\u017cytkownikowi wyb\u00f3r pliku EKG. Po wybraniu pliku, aktywuje pola wej\u015bciowe, umo\u017cliwiaj\u0105c wprowadzenie cz\u0119stotliwo\u015bci, czasu pocz\u0105tkowego i ko\u0144cowego, minimalnej i maksymalnej amplitudy oraz etykiet osi X i Y.</p> <pre><code>def loadFile(self):\n    self.path = filedialog.askopenfilename(initialdir=\"/\", title=\"Select EKG signal file\",\n                                           filetypes=((\"txt files\", \"*.txt\"), (\"all files\", \"*.*\")))\n    # Activate entry fields after loading a file\n    self.frequency_entry.config(state='normal')\n    self.start_time_entry.config(state='normal')\n    self.end_time_entry.config(state='normal')\n    self.min_amp_entry.config(state='normal')\n    self.max_amp_entry.config(state='normal')\n    self.label_x_entry.config(state='normal')\n    self.label_y_entry.config(state='normal')\n</code></pre>"},{"location":"readFile/#etykiety","title":"Etykiety","text":"<ul> <li> <p>frequency_entry: <code>tk.Entry</code>   Pole wej\u015bciowe do wprowadzenia cz\u0119stotliwo\u015bci pr\u00f3bkowania sygna\u0142u EKG. U\u017cytkownik wprowadza warto\u015b\u0107 liczbow\u0105, kt\u00f3ra okre\u015bla, jak cz\u0119sto pr\u00f3bki sygna\u0142u s\u0105 pobierane na sekund\u0119.</p> </li> <li> <p>start_time_entry: <code>tk.Entry</code>   Pole wej\u015bciowe do wprowadzenia czasu pocz\u0105tkowego. U\u017cytkownik wprowadza warto\u015b\u0107, kt\u00f3ra okre\u015bla pocz\u0105tek zakresu czasu do analizy sygna\u0142u EKG.</p> </li> <li> <p>end_time_entry: <code>tk.Entry</code>   Pole wej\u015bciowe do wprowadzenia czasu ko\u0144cowego. U\u017cytkownik wprowadza warto\u015b\u0107, kt\u00f3ra okre\u015bla koniec zakresu czasu do analizy sygna\u0142u EKG.</p> </li> <li> <p>min_amp_entry: <code>tk.Entry</code>   Pole wej\u015bciowe do wprowadzenia minimalnej amplitudy sygna\u0142u. U\u017cytkownik wprowadza warto\u015b\u0107, kt\u00f3ra okre\u015bla dolny pr\u00f3g amplitudy sygna\u0142u EKG do analizy.</p> </li> <li> <p>max_amp_entry: <code>tk.Entry</code>   Pole wej\u015bciowe do wprowadzenia maksymalnej amplitudy sygna\u0142u. U\u017cytkownik wprowadza warto\u015b\u0107, kt\u00f3ra okre\u015bla g\u00f3rny pr\u00f3g amplitudy sygna\u0142u EKG do analizy.</p> </li> <li> <p>label_x_entry: <code>tk.Entry</code>   Pole wej\u015bciowe do wprowadzenia etykiety osi X. U\u017cytkownik wprowadza tekst, kt\u00f3ry b\u0119dzie u\u017cywany jako etykieta osi poziomej na wykresie sygna\u0142u EKG.</p> </li> <li> <p>label_y_entry: <code>tk.Entry</code>   Pole wej\u015bciowe do wprowadzenia etykiety osi Y. U\u017cytkownik wprowadza tekst, kt\u00f3ry b\u0119dzie u\u017cywany jako etykieta osi pionowej na wykresie sygna\u0142u EKG.</p> </li> </ul>"},{"location":"showPlot/","title":"Wy\u015bwietlanie wykresu","text":"<p>Poni\u017cszy kod zawiera zestaw funkcji do przetwarzania i wizualizacji sygna\u0142\u00f3w EKG oraz  sygna\u0142\u00f3w sinusoidalnych. Kod umo\u017cliwia  przeprowadzanie filtracji  wysokoprzepustowej i niskoprzepustowej oraz aktualizacj\u0119 wykresu sygna\u0142u z odpowiednimi ustawieniami  osi i parametr\u00f3w. Dodatkowo, kod pozwala na generowanie i wy\u015bwietlanie sygna\u0142\u00f3w sinusoidalnych  o okre\u015blonych cz\u0119stotliwo\u015bciach, a tak\u017ce na tworzenie sygna\u0142\u00f3w b\u0119d\u0105cych sum\u0105 kilku sygna\u0142\u00f3w  sinusoidalnych. Mo\u017cliwe jest r\u00f3wnie\u017c obliczanie i wy\u015bwietlanie widma amplitudowego sygna\u0142u  za pomoc\u0105 transformaty Fouriera oraz odtwarzanie sygna\u0142u po zastosowaniu odwrotnej transformaty  Fouriera. Kod zawiera funkcjonalno\u015b\u0107 umo\u017cliwiaj\u0105c\u0105 zapisywanie aktualnego wykresu do pliku. Te funkcje wspieraj\u0105 interaktywn\u0105 analiz\u0119 i manipulacj\u0119 sygna\u0142ami w aplikacji.</p>"},{"location":"showPlot/#metody","title":"Metody","text":""},{"location":"showPlot/#konstruktor-klasy-plot","title":"Konstruktor klasy Plot","text":"<p>Funkcja <code>__init__</code> jest konstruktorem obkietu <code>plot</code>, kt\u00f3ry reprezentuje wykres.  Podczas inicjalizacji funkcja przyjmuje jako argument <code>master</code>, kt\u00f3ry odnosi  si\u0119 do g\u0142\u00f3wnego okna aplikacji Tkinter. W konstruktorze tworzony jest obiekt figury  <code>fig</code>z okre\u015blonym rozmiarem (10x6 cali) i rozdzielczo\u015bci\u0105 (100 DPI), dodawany jest  pojedynczy subplot do figury za pomoc\u0105 <code>add_subplot(111)</code>, nast\u0119pnie tworzone jest  p\u0142\u00f3tno <code>canvas</code> do rysowania  wykresu, wykorzystuj\u0105c <code>FigureCanvasTkAgg</code>, i  jest ono integrowane z g\u0142\u00f3wnym oknem aplikacji (<code>master</code>). Nast\u0119pnie rysowane jest  p\u0142\u00f3tno <code>canvas</code> i jest ono umieszczane w uk\u0142adzie siatki Tkinter za pomoc\u0105  metody <code>grid</code>. Inicjalizowana jest r\u00f3wnie\u017c zmienna <code>line</code> jako <code>None</code>, kt\u00f3ra mo\u017ce by\u0107 p\u00f3\u017aniej u\u017cyta  do przechowywania odniesienia do rysowanej linii na wykresie.</p> <pre><code>def __init__(self, master):\n    self.master = master\n    self.fig = Figure(figsize=(10, 6), dpi=100)\n    self.plot = self.fig.add_subplot(111)\n    self.canvas = FigureCanvasTkAgg(self.fig, master=self.master)\n    self.canvas.draw()\n    self.canvas.get_tk_widget().grid(row=0, column=1, rowspan=12)\n    self.line = None\n</code></pre>"},{"location":"showPlot/#parametry","title":"Parametry","text":"<ul> <li>master: <code>tkinter</code>   G\u0142\u00f3wne okno aplikacji Tkinter.</li> </ul>"},{"location":"showPlot/#wyswietlanie-wykresu_1","title":"Wy\u015bwietlanie wykresu","text":"<p>Funkcja pobiera dane wej\u015bciowe od u\u017cytkownika dotycz\u0105ce sygna\u0142u EKG.  Najpierw pobiera warto\u015bci cz\u0119stotliwo\u015bci pr\u00f3bkowania, czasu pocz\u0105tkowego i ko\u0144cowego,  minimalnej i maksymalnej amplitudy oraz etykiet osi X i Y.  Nast\u0119pnie oblicza d\u0142ugo\u015b\u0107 sygna\u0142u EKG. Je\u015bli zaznaczona jest opcja analizy cz\u0119stotliwo\u015bci,  wykonuje odpowiednie przekszta\u0142cenia. W przeciwnym razie, aktualizuje wykres sygna\u0142u. Kod tak\u017ce sprawdza, czy zaznaczono opcje filtracji wysokoprzepustowej i niskoprzepustowej.  Je\u015bli tak, pobiera parametry filtracji i stosuje odpowiednie filtry do sygna\u0142u,  a nast\u0119pnie ponownie aktualizuje wykres z przefiltrowanym sygna\u0142em.</p> <pre><code>def show_plot():\n    frequency = float(self.frequency_entry.get())\n    start_time = float(self.start_time_entry.get())\n    end_time = float(self.end_time_entry.get())\n    min_amp = float(self.min_amp_entry.get())\n    max_amp = float(self.max_amp_entry.get())\n    lab_x = self.label_x_entry.get()\n    lab_y = self.label_y_entry.get()\n    file = File(self.path, frequency=frequency)\n    App.time, App.signal = file.load_EKG()\n    App.length = len(App.signal)  # Directly calculate the length of the signal\n\n    if self.fq_status.get():\n        self.plot_signal.show_frequency_analysis(App.signal, frequency)\n    else:\n        self.plot_signal.update_Plot(App.time, App.signal, start_time, end_time, min_amp, max_amp, \"EKG SIGNAL\",\n                                     lab_x, lab_y)\n\n    if self.fl_high_status.get():\n        if self.fl_high_entry.get() and self.sample_fq_high_entry.get() and self.fl_order_high_entry.get():\n            cut_off = float(self.fl_high_entry.get())\n            fs = float(self.sample_fq_high_entry.get())\n            order = float(self.fl_order_high_entry.get())\n            b, a = self.plot_signal.butter_highpass(cut_off, fs, order)\n            filtered_signal = filtfilt(b, a, App.signal)\n            self.plot_signal.update_Plot(App.time, filtered_signal, start_time, end_time, min_amp, max_amp,\n                                         \"EKG SIGNAL\", lab_x, lab_y)\n            self.new_signal = filtered_signal\n\n    if self.fl_low_status.get():\n        if self.fl_low_entry.get() and self.sample_fq_low_entry.get() and self.fl_order_low_entry.get():\n            cut_off = float(self.fl_low_entry.get())\n            fs = float(self.sample_fq_low_entry.get())\n            order = float(self.fl_order_low_entry.get())\n            b, a = self.plot_signal.butter_lowpass(cut_off, fs, order)\n            filtered_signal = filtfilt(b, a, self.new_signal)\n            self.plot_signal.update_Plot(App.time, filtered_signal, start_time, end_time, min_amp, max_amp,\n                                         \"EKG SIGNAL\", lab_x, lab_y)\n            self.new_signal = filtered_signal\n</code></pre>"},{"location":"showPlot/#aktualizowanie-wykresu","title":"Aktualizowanie wykresu","text":"<p>Funkcja <code>update_Plot</code> aktualizuje wykres sygna\u0142u EKG w obiekcie <code>Plot</code>.  Najpierw sprawdza, czy zmienna <code>self.line</code> nie jest pusta; je\u015bli tak, usuwa istniej\u0105c\u0105 lini\u0119 z wykresu.  Nast\u0119pnie czy\u015bci bie\u017c\u0105cy wykres za pomoc\u0105 metody <code>clear</code>. </p> <p>Funkcja rysuje nowy wykres, u\u017cywaj\u0105c dostarczonych danych czasowych (<code>time</code>) i sygna\u0142owych (<code>signal</code>), oraz ustawia zakres osi X od <code>start_time</code> do <code>end_time</code> i zakres osi Y od <code>min_amp</code> do <code>max_amp</code>.  Dodaje tytu\u0142 wykresu (<code>title</code>), etykiety osi X (<code>xlabel</code>) i osi Y (<code>ylabel</code>).  W\u0142\u0105cza r\u00f3wnie\u017c siatk\u0119 na wykresie za pomoc\u0105 metody <code>grid</code>.</p> <p>Po zaktualizowaniu wszystkich element\u00f3w, funkcja rysuje wykres na p\u0142\u00f3tnie (<code>canvas.draw</code>) i  zapisuje referencj\u0119 do nowej linii wykresu w <code>self.line</code> dla przysz\u0142ych aktualizacji.</p> <pre><code>    def update_Plot(self, time, signal, start_time, end_time, min_amp, max_amp, title, xlabel, ylabel):\n        if self.line:\n            self.line.remove()\n        self.plot.clear()\n        self.plot.plot(time, signal, label=\"EKG Signal\")\n        self.plot.set_xlim(start_time, end_time)\n        self.plot.set_ylim(min_amp, max_amp)\n        self.plot.set_title(title)\n        self.plot.set_xlabel(xlabel)\n        self.plot.set_ylabel(ylabel)\n        self.plot.grid(True)\n        self.canvas.draw()\n        self.line = self.plot.lines[0]\n</code></pre>"},{"location":"showPlot/#wyswietlanie-fali-sinusoidalnej","title":"Wy\u015bwietlanie fali sinusoidalnej","text":"<p>Funkcja generuje i wy\u015bwietla wykres sygna\u0142u sinusoidalnego. Najpierw pobiera warto\u015bci czasu pocz\u0105tkowego i ko\u0144cowego z p\u00f3l wej\u015bciowych <code>start_time_entry</code> i <code>end_time_entry</code>. Nast\u0119pnie ustala minimaln\u0105 i maksymaln\u0105 amplitud\u0119 sygna\u0142u na podstawie aktualnego sygna\u0142u w <code>signal</code>. Etykiety osi X i Y s\u0105  pobierane z p\u00f3l <code>label_x_entry</code> i <code>label_y_entry</code>.</p> <p>Sygna\u0142 sinusoidalny jest generowany z cz\u0119stotliwo\u015bci\u0105 50 Hz.  Liczba pr\u00f3bek sygna\u0142u wynosi 65536, a czas trwania sygna\u0142u jest obliczany jako r\u00f3\u017cnica mi\u0119dzy  czasem ko\u0144cowym a pocz\u0105tkowym. Interwa\u0142 pr\u00f3bkowania jest obliczany jako czas trwania podzielony  przez liczb\u0119 pr\u00f3bek. Na tej podstawie tworzony jest wektor czasu <code>time</code>. Nast\u0119pnie generowany jest sygna\u0142 sinusoidalny <code>signal</code> przy u\u017cyciu funkcji sinusoidalnej.  Na koniec, wykres sygna\u0142u jest aktualizowany za pomoc\u0105 metody <code>update_Plot</code>, kt\u00f3ra wykorzystuje wektor czasu, sygna\u0142, czasy pocz\u0105tkowy i ko\u0144cowy, minimaln\u0105 i maksymaln\u0105 amplitud\u0119  oraz etykiety osi X i Y.</p> <pre><code>def show_sin_plot():\n    start_time = float(self.start_time_entry.get())\n    end_time = float(self.end_time_entry.get())\n    min_amp = np.min(App.signal)\n    max_amp = np.max(App.signal)\n    self.label_x = self.label_x_entry.get()  # Get value from the X-axis text field\n    self.label_y = self.label_y_entry.get()  # Get value from the Y-axis text field\n\n    # Parameters for the sine wave\n    frequency = 50  # Hz\n    App.length = 65536  # Number of samples\n    duration = end_time - start_time\n    sampling_interval = duration / App.length\n    # Create time vector\n    App.time = np.arange(0, duration, sampling_interval)\n    # Generate sine wave\n    App.signal = np.sin(2 * np.pi * frequency * App.time)\n\n    self.plot_signal.update_Plot(App.time, App.signal, start_time, end_time, min_amp, max_amp, \"SIN SIGNAL\",\n                                 self.label_x, self.label_y)\n</code></pre>"},{"location":"showPlot/#wyswietlanie-sumy-dwoch-sygnaow-sinusoidalnych","title":"Wy\u015bwietlanie sumy dw\u00f3ch sygna\u0142\u00f3w sinusoidalnych","text":"<p>Funkcja generuje i wy\u015bwietla wykres sygna\u0142u b\u0119d\u0105cego sum\u0105 dw\u00f3ch sygna\u0142\u00f3w sinusoidalnych  o r\u00f3\u017cnych cz\u0119stotliwo\u015bciach. Czas pocz\u0105tkowy ustawiany jest na 0 a czas ko\u0144cowy na 0,5 sekundy.  Nast\u0119pnie obliczana jest minimaln i maksymaln amplituda sygna\u0142u na podstawie aktualnego sygna\u0142u  w <code>signal</code>. Etykiety osi X i Y s\u0105 pobierane z p\u00f3l <code>label_x_entry</code> i <code>label_y_entry</code>.</p> <p>Dwa sygna\u0142y sinusoidalne s\u0105 generowane z cz\u0119stotliwo\u015bciami odpowiednio 50 Hz i 60 Hz.  Liczba pr\u00f3bek sygna\u0142u wynosi 65536, a czas trwania sygna\u0142u jest obliczany jako  r\u00f3\u017cnica mi\u0119dzy czasem ko\u0144cowym a pocz\u0105tkowym. Interwa\u0142 pr\u00f3bkowania jest obliczany jako czas  trwania podzielony przez liczb\u0119 pr\u00f3bek. Na tej podstawie tworzony jest wektor czasu <code>time</code>.</p> <p>Nast\u0119pnie generowane s\u0105 dwa sygna\u0142y sinusoidalne <code>sine_wave1</code> i <code>sine_wave2</code> dla odpowiednich  cz\u0119stotliwo\u015bci. Te dwa sygna\u0142y s\u0105 sumowane, tworz\u0105c ko\u0144cowy sygna\u0142 <code>signal</code>.</p> <p>Na koniec, wykres sumy dw\u00f3ch sygna\u0142\u00f3w sinusoidalnych jest aktualizowany za pomoc\u0105 metody <code>update_Plot</code>, kt\u00f3ra wykorzystuje wektor czasu, sygna\u0142, czasy pocz\u0105tkowy i ko\u0144cowy, minimaln\u0105 i maksymaln\u0105 amplitud\u0119 oraz etykiety osi X i Y.</p> <pre><code>def show_2sin_plot():\n    start_time = 0\n    end_time = 0.5\n    min_amp = np.min(App.signal)\n    max_amp = np.max(App.signal)\n    self.label_x = self.label_x_entry.get()  # Get value from the X-axis text field\n    self.label_y = self.label_y_entry.get()  # Get value from the Y-axis text field\n\n    # Parameters for the sine waves\n    frequency1 = 50  # Hz\n    frequency2 = 60  # Hz\n    App.length = 65536  # Number of samples\n    duration = end_time - start_time\n    sampling_interval = duration / App.length\n    # Create time vector\n    App.time = np.arange(0, duration, sampling_interval)\n    # Generate sine wave for the first frequency\n    sine_wave1 = np.sin(2 * np.pi * frequency1 * App.time)\n    # Generate sine wave for the second frequency\n    sine_wave2 = np.sin(2 * np.pi * frequency2 * App.time)\n    # Mix the sine waves\n    App.signal = sine_wave1 + sine_wave2\n\n    self.plot_signal.update_Plot(App.time, App.signal, start_time, end_time, min_amp, max_amp, \"SIN SIGNAL\",\n                                 self.label_x, self.label_y)\n</code></pre>"},{"location":"showPlot/#transformata-fouriera","title":"Transformata Fouriera","text":"<p>Funkcja oblicza i wy\u015bwietla widmo amplitudowe sygna\u0142u za pomoc\u0105 transformaty Fouriera. Najpierw oblicza dyskretn\u0105 transformat\u0119 Fouriera (FFT) sygna\u0142u <code>signal</code>, a nast\u0119pnie oblicza  widmo amplitudowe, bior\u0105c warto\u015bci bezwzgl\u0119dne <code>FFT</code>.</p> <p>Czas trwania sygna\u0142u jest ustawiony na 10 sekund, a interwa\u0142 pr\u00f3bkowania obliczany jako czas  trwania podzielony przez d\u0142ugo\u015b\u0107 sygna\u0142u <code>length</code>.</p> <p>Kolejno, okre\u015blana jest o\u015b cz\u0119stotliwo\u015bci za pomoc\u0105 funkcji <code>fftfreq</code>, kt\u00f3ra zwraca pr\u00f3bki cz\u0119stotliwo\u015bci  dla <code>FFT</code>. Wyznaczane s\u0105 cz\u0119stotliwo\u015bci, kt\u00f3re s\u0105 wi\u0119ksze lub r\u00f3wne zeru, oraz odpowiadaj\u0105ce im  warto\u015bci widma amplitudowego.</p> <p>Na koniec, tworzony jest wykres widma amplitudowego z cz\u0119stotliwo\u015bciami na osi X i  amplitud\u0105 na osi Y, dodaje tytu\u0142 wykresu oraz etykiety osi, a nast\u0119pnie wy\u015bwietlany jest wykres za pomoc\u0105 <code>plt.show()</code>.</p> <pre><code>def do_fft():\n    # Calculate the discrete Fourier transform\n    Fft = fft(App.signal)\n    # Calculate the amplitude spectrum\n    spectrum = np.abs(Fft)\n\n    duration = 10  # duration of the signal\n    sampling_interval = duration / App.length\n\n    # Determine the frequency axis\n    frequencies = fftfreq(App.length, sampling_interval)\n    indices = np.where(frequencies &gt;= 0)\n    frequencies = frequencies[indices]\n    spectrum = spectrum[indices]\n\n    plt.plot(frequencies, spectrum)\n    plt.title('Amplitude Spectrum')\n    plt.xlabel('Frequency [Hz]')\n    plt.ylabel('Amplitude')\n    plt.show()\n</code></pre>"},{"location":"showPlot/#odwrotna-transformata-fouriera","title":"Odwrotna transformata Fouriera","text":"<p>Funkcja <code>do_ifft</code> oblicza i wy\u015bwietla sygna\u0142 po zastosowaniu odwrotnej transformaty Fouriera (IFFT).  Najpierw pobierane s\u0105 warto\u015bci czasu pocz\u0105tkowego i ko\u0144cowego z p\u00f3l wej\u015bciowych <code>start_time_entry</code>  i <code>end_time_entry</code>. Nast\u0119pnie obliczana jest dyskretna transformata Fouriera (FFT) sygna\u0142u <code>signal</code> i wykonywana jest odwrotna transformata Fouriera (IFFT) do uzyskanego <code>FFT</code>, aby odzyska\u0107  oryginalny sygna\u0142 w dziedzinie czasu.</p> <p>Na koniec, tworzony jest wykres rzeczywistej cz\u0119\u015bci sygna\u0142u po <code>IFFT</code> w odniesieniu do wektora  czasu <code>time</code>, dodawane s\u0105 tytu\u0142 wykresu oraz etykiety osi, w\u0142\u0105czana jest siatka i ustawiany jest zakres osi X na warto\u015bci od <code>start_time</code> do <code>end_time</code>. Wykres jest wy\u015bwietlany za pomoc\u0105 funkcji  <code>plt.show()</code>.</p> <pre><code>def do_ifft():\n    start_time = float(self.start_time_entry.get())\n    end_time = float(self.end_time_entry.get())\n    # Calculate the discrete Fourier transform\n    Fft = fft(App.signal)\n    # Calculate the amplitude spectrum\n\n    # Determine the frequency axis\n    inverse_fft = ifft(Fft)\n\n    plt.plot(App.time, inverse_fft.real)  # Real part of the inverse FFT\n    plt.title('Signal after Inverse FFT')\n    plt.xlabel('Time [s]')\n    plt.ylabel('Amplitude')\n    plt.grid(True)\n    plt.xlim(start_time, end_time)\n    plt.show()\n</code></pre>"},{"location":"showPlot/#filtr-dolnoprzepustowy","title":"Filtr dolnoprzepustowy","text":"<p>Metoda statyczna <code>butter_lowpass</code> tworzy dolnoprzepustowy filtr Butterwortha.  Przyjmuje trzy parametry: <code>cut_off</code> (cz\u0119stotliwo\u015b\u0107 odci\u0119cia), <code>fs</code> (cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania)  oraz <code>order</code> (rz\u0105d filtra). Najpierw oblicza cz\u0119stotliwo\u015b\u0107 Nyquista jako po\u0142ow\u0119 cz\u0119stotliwo\u015bci  pr\u00f3bkowania <code>fs</code>. Nast\u0119pnie normalizuje cz\u0119stotliwo\u015b\u0107 odci\u0119cia <code>cut_off</code> dziel\u0105c j\u0105 przez  cz\u0119stotliwo\u015b\u0107 Nyquista, co jest wymagane przez funkcj\u0119 <code>butter</code> z pakietu SciPy.  Na ko\u0144cu funkcja <code>butter</code> generuje wsp\u00f3\u0142czynniki filtra <code>b</code> i <code>a</code>, kt\u00f3re s\u0105 zwracane jako wynik.</p> <pre><code>@staticmethod\n    def butter_lowpass(cut_off, fs, order):\n        nyquist = 0.5 * fs\n        normal_cutoff = cut_off / nyquist\n        b, a = butter(order, normal_cutoff, btype='low', analog=False)\n        return b, a\n</code></pre>"},{"location":"showPlot/#parametry_1","title":"Parametry","text":"<ul> <li>cut_off: <code>float</code>   Cz\u0119stotliwo\u015b\u0107 odci\u0119cia filtra w Hz.</li> <li>fs: <code>float</code>   Cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania sygna\u0142u w Hz.</li> <li>order: <code>int</code>   Rz\u0105d filtra Butterwortha.</li> </ul>"},{"location":"showPlot/#filtr-gornoprzepustowy","title":"Filtr g\u00f3rnoprzepustowy","text":"<p>Metoda statyczna <code>butter_highpass</code> tworzy g\u00f3rnoprzepustowy filtr Butterwortha.  Przyjmuje trzy parametry: <code>cut_off</code> (cz\u0119stotliwo\u015b\u0107 odci\u0119cia), <code>fs</code> (cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania)  oraz <code>order</code> (rz\u0105d filtra). Najpierw oblicza cz\u0119stotliwo\u015b\u0107 Nyquista jako po\u0142ow\u0119 cz\u0119stotliwo\u015bci  pr\u00f3bkowania <code>fs</code>. Nast\u0119pnie normalizuje cz\u0119stotliwo\u015b\u0107 odci\u0119cia <code>cut_off</code> dziel\u0105c j\u0105  przez cz\u0119stotliwo\u015b\u0107 Nyquista, co jest wymagane przez funkcj\u0119 <code>butter</code> z pakietu SciPy.  Na ko\u0144cu funkcja <code>butter</code> generuje wsp\u00f3\u0142czynniki filtra <code>b</code> i <code>a</code> dla filtra g\u00f3rnoprzepustowego,  kt\u00f3re s\u0105 zwracane jako wynik.</p> <pre><code>    @staticmethod\n    def butter_highpass(cut_off, fs, order):\n        \"\"\"\n        Create a Butterworth high-pass filter.\n        \"\"\"\n        nyquist = 0.5 * fs\n        normal_cutoff = cut_off / nyquist\n        b, a = butter(order, normal_cutoff, btype='high', analog=False)\n        return b, a\n</code></pre>"},{"location":"showPlot/#parametry_2","title":"Parametry","text":"<ul> <li>cut_off: <code>float</code>   Cz\u0119stotliwo\u015b\u0107 odci\u0119cia filtra w Hz.</li> <li>fs: <code>float</code>   Cz\u0119stotliwo\u015b\u0107 pr\u00f3bkowania sygna\u0142u w Hz.</li> <li>order: <code>int</code>   Rz\u0105d filtra Butterwortha.</li> </ul>"},{"location":"showPlot/#zapisywanie-wykresu-do-pliku","title":"Zapisywanie wykresu do pliku","text":"<p>Funkcja <code>save_plot</code> umo\u017cliwia zapisanie aktualnego wykresu do pliku w wybranym formacie graficznym.  Najpierw otwierane jest okno dialogowe, kt\u00f3re pozwala u\u017cytkownikowi wybra\u0107 \u015bcie\u017ck\u0119 do pliku oraz  format zapisu (PNG, JPEG lub PDF). Wybrany format jest okre\u015blany przez rozszerzenie pliku.</p> <p>Je\u015bli u\u017cytkownik wybierze \u015bcie\u017ck\u0119 do pliku, funkcja pr\u00f3buje zapisa\u0107 bie\u017c\u0105cy wykres za pomoc\u0105 metody  <code>savefig</code> obiektu <code>plot_signal.fig</code> w wybranej lokalizacji. W przypadku pomy\u015blnego zapisu,  wypisywana jest informacja o sukcesie. Je\u015bli wyst\u0105pi b\u0142\u0105d podczas zapisywania,  b\u0142\u0105d jest przechwytywany i wy\u015bwietlana jest wiadomo\u015b\u0107 o b\u0142\u0119dzie.</p> <pre><code>def save_plot():\n    file_path = filedialog.asksaveasfilename(defaultextension=\".png\",\n                                             filetypes=[(\"PNG files\", \"*.png\"),\n                                                        (\"JPEG files\", \"*.jpg\"),\n                                                        (\"PDF files\", \"*.pdf\")])\n    if file_path:  # If file path is selected\n        try:\n            # Saving selected plot in selected format\n            self.plot_signal.fig.savefig(file_path)\n            print(\"Plot saved successfully.\")\n        except Exception as e:\n            print(\"Error while saving plot:\", e)\n</code></pre>"}]}